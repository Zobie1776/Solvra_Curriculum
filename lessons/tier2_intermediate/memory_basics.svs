//==================================================
// File: memory_basics.svs
//==================================================
// Author: ZobieLabs
// License: Duality Public License (DPL v1.0)
// Goal: Inspect SolvraCore allocator stats from SolvraScript
// Objective: Demonstrate memory tracking and allocation monitoring
//==================================================

//==================================================
// Section 1.0 - Lesson Objective
//==================================================

// Interactive guided tutorial: Monitor and manage memory
// Run with: ./scripts/build.sh lessons/tier2_intermediate/memory_basics.svs

//==================================================
// Section 2.0 - Tutorial Execution
//==================================================

import <vector>;

const SAMPLE_COUNT = 3;

fn log_stats(stage) {
    let stats = core_memory_stats();
    println(stage, ":");
    println("  Capacity: ", stats.capacity_bytes, " bytes");
    println("  Used:     ", stats.used_bytes, " bytes");
    println("  Allocations: ", stats.allocations);
}

fn allocate_vectors(count) {
    let mut data = [];
    let mut index = 0;
    while index < count {
        let mut item = vector.make();
        item = vector.append(item, index);
        item = vector.append(item, index * 2);
        data = push(data, item);
        index = index + 1;
    }
    return data;
}

fn run_tutorial() {
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘  Tier 2: Memory Basics and Monitoring                     â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();

    println("ğŸ“š What you'll learn:");
    println("  â€¢ How to monitor memory usage with core_memory_stats()");
    println("  â€¢ How to track allocations and capacity");
    println("  â€¢ Why memory management matters in embedded systems");
    println("  â€¢ How SolvraCore's memory contract works");
    println();

    println("Let's begin!");
    println();

    // Concept 1: Why Memory Matters
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 1: Why Memory Management Matters");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("In embedded systems and resource-constrained environments:");
    println("  â€¢ Memory is limited (KB or MB, not GB)");
    println("  â€¢ Memory leaks can crash the system");
    println("  â€¢ Efficient allocation improves performance");
    println("  â€¢ Tracking usage helps debug issues");
    println();
    println("SolvraCore provides visibility into memory usage through");
    println("the memory contract API.");
    println();

    let continue1 = inp("Press Enter to continue...");
    println();

    // Concept 2: core_memory_stats()
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 2: Monitoring with core_memory_stats()");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Use core_memory_stats() to inspect allocator state:");
    println("  let stats = core_memory_stats();");
    println("  println(stats.capacity_bytes);  // Total capacity");
    println("  println(stats.used_bytes);      // Currently used");
    println("  println(stats.allocations);     // Number of allocations");
    println();
    println("Let's check the current state:");
    println();
    log_stats("[Start]");
    println();

    let continue2 = inp("Press Enter to continue...");
    println();

    // Concept 3: Tracking Allocations
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 3: Tracking Allocations");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Let's allocate some vectors and watch memory change:");
    println("  We'll create ", SAMPLE_COUNT, " vectors");
    println("  Each vector will hold 2 elements");
    println();

    println("Allocating ", SAMPLE_COUNT, " vectors...");
    let payload = allocate_vectors(SAMPLE_COUNT);
    println("Created ", len(payload), " vector(s)");
    println();

    log_stats("[After Allocation]");
    println();

    println("Notice how the stats changed!");
    println("  â€¢ used_bytes increased (vectors consume memory)");
    println("  â€¢ allocations increased (new objects created)");
    println();

    let continue3 = inp("Press Enter to continue...");
    println();

    // Concept 4: Memory Contract Benefits
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 4: SolvraCore's Memory Contract");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("The memory contract provides:");
    println("  â€¢ Runtime visibility into allocations");
    println("  â€¢ Detection of memory leaks");
    println("  â€¢ Performance profiling data");
    println("  â€¢ Debug information for optimization");
    println();
    println("Use cases:");
    println("  â€¢ Embedded systems with strict memory limits");
    println("  â€¢ Long-running services that must avoid leaks");
    println("  â€¢ Performance-critical applications");
    println("  â€¢ AI agents managing resources");
    println();

    // Quick self-check
    let stats = core_memory_stats();
    if stats.allocations > 0 {
        println("[Self Check] Allocator is tracking work!");
        println("  We've recorded ", stats.allocations, " allocation(s)");
    } else {
        println("[Self Check] Unexpected zero allocations - investigate!");
    }
    println();

    let continue4 = inp("Press Enter to continue...");
    println();

    // Try-It-Yourself Section
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("âœï¸  Try-It-Yourself Challenge");
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();
    println("Let's test your understanding!");
    println();

    println("Question: Which field shows how much memory is currently used?");
    println("  a) capacity_bytes");
    println("  b) used_bytes");
    println("  c) allocations");
    println();

    let answer = inp("Your answer (a/b/c): ");
    println();

    if answer == "b" || answer == "B" {
        println("âœ“ Correct! used_bytes shows current memory consumption.");
        println("  capacity_bytes = total available memory");
        println("  used_bytes = currently consumed memory");
        println("  allocations = number of allocation events");
    } else {
        println("âœ— Not quite. The correct answer is 'b' â€” used_bytes");
        println("  capacity_bytes tells you the total available");
        println("  used_bytes tells you how much is currently in use");
        println("  allocations is a count, not a size measurement");
    }
    println();

    let continue5 = inp("Press Enter to see summary...");
    println();

    // Summary
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("ğŸ“‹ Lesson Summary");
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();
    println("Today you learned:");
    println("  âœ“ How to monitor memory with core_memory_stats()");
    println("  âœ“ How to track capacity, usage, and allocations");
    println("  âœ“ Why memory management is critical for embedded systems");
    println("  âœ“ How SolvraCore's memory contract provides visibility");
    println();
    println("Key Takeaway:");
    println("  The memory contract provides visibility into runtime resource");
    println("  usage. This is essential for embedded systems, long-running");
    println("  services, and performance-critical applications!");
    println();

    // Next Steps
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("What would you like to do?");
    println("  [1] View lesson again");
    println("  [2] Continue to Tier 3 lessons");
    println("  [3] Exit");
    println();

    let choice = inp("Your choice (1/2/3): ");
    println();

    if choice == "1" {
        println("ğŸ“– Restarting lesson...");
        println();
        run_tutorial();
    } else if choice == "2" {
        println("ğŸ“ Excellent! You've completed Tier 2!");
        println("   Ready for Tier 3? Run:");
        println("   ./scripts/learn.sh");
    } else {
        println("ğŸ‘‹ Thanks for learning with us! See you next time.");
    }
    println();
}

fn main() {
    run_tutorial();
}

//--------------------------------------------------
// End comments: Demonstrates memory monitoring through SolvraCore allocator stats
// @ZNOTE: Memory contract provides visibility into runtime resource usage
//--------------------------------------------------

//==================================================
// End of file
//==================================================
