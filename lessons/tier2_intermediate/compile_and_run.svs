//==================================================
// File: compile_and_run.svs
//==================================================
// Author: ZobieLabs
// License: Duality Public License (DPL v1.0)
// Goal: Execute a compiled .svc module from SolvraScript and inspect results
// Objective: Demonstrate loading and executing compiled bytecode modules
//==================================================

//==================================================
// Section 1.0 - Lesson Objective
//==================================================

// Interactive guided tutorial: Execute compiled bytecode modules
// Run with: ./scripts/build.sh lessons/tier2_intermediate/compile_and_run.svs

//==================================================
// Section 2.0 - Tutorial Execution
//==================================================

import "Solvra_pkg/solvra_core/samples/add_numbers.svc" as add_module;

fn run_tutorial() {
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘  Tier 2: Compile and Run Bytecode Modules                 â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();

    println("ğŸ“š What you'll learn:");
    println("  â€¢ How to import compiled .svc bytecode modules");
    println("  â€¢ How to execute modules with core_module_execute()");
    println("  â€¢ How to manage module handles and memory");
    println("  â€¢ Why bytecode modules matter for SolvraCore");
    println();

    println("Let's begin!");
    println();

    // Concept 1: What are Compiled Modules?
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 1: Understanding Compiled Modules");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("SolvraCore compiles SolvraScript (.svs) into bytecode (.svc).");
    println("Benefits of compiled modules:");
    println("  â€¢ Faster execution (pre-compiled)");
    println("  â€¢ Smaller footprint (optimized bytecode)");
    println("  â€¢ Protection of source code (distributed as binary)");
    println("  â€¢ Cross-platform compatibility");
    println();
    println("Think of .svc files as the 'machine code' for SolvraCore VM!");
    println();

    let continue1 = inp("Press Enter to continue...");
    println();

    // Concept 2: Importing Modules
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 2: Importing Compiled Modules");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Syntax for importing .svc modules:");
    println("  import \"path/to/module.svc\" as module_name;");
    println();
    println("This lesson imports add_numbers.svc:");
    println("  import \"Solvra_pkg/.../add_numbers.svc\" as add_module;");
    println();
    println("The module is loaded into memory and ready to execute!");
    println();

    let handle = add_module.module.handle;
    println("Module handle obtained: ", handle);
    println();

    let continue2 = inp("Press Enter to continue...");
    println();

    // Concept 3: Executing Modules
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 3: Executing Bytecode Modules");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Execute modules with core_module_execute(handle):");
    println();
    println("Before execution, let's check memory:");
    let stats_before = core_memory_stats();
    println("  Allocations: ", stats_before.allocations);
    println("  Used bytes:  ", stats_before.used_bytes);
    println();

    println("Executing add_numbers.svc...");
    let result = core_module_execute(handle);
    println();
    println("Module returned: ", result);
    println();

    let stats_after = core_memory_stats();
    println("After execution:");
    println("  Allocations: ", stats_after.allocations);
    println("  Used bytes:  ", stats_after.used_bytes);
    println();

    let continue3 = inp("Press Enter to continue...");
    println();

    // Concept 4: Module Lifecycle
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 4: Module Lifecycle Management");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Module lifecycle:");
    println("  1. Import: Load module into memory");
    println("  2. Execute: Run module bytecode");
    println("  3. Release: Free module resources");
    println();
    println("Syntax:");
    println("  let handle = module.module.handle;");
    println("  let result = core_module_execute(handle);");
    println("  core_module_release(handle);");
    println();
    println("Proper lifecycle management prevents memory leaks!");
    println();

    // Quick self-check
    if result == 5 {
        println("[Self Check] add_numbers.svc returned expected result (2 + 3 = 5)!");
    } else {
        println("[Self Check] Unexpected result from compiled module: ", result);
    }
    println();

    println("Releasing module handle...");
    core_module_release(handle);
    println("Module resources freed!");
    println();

    let continue4 = inp("Press Enter to continue...");
    println();

    // Try-It-Yourself Section
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("âœï¸  Try-It-Yourself Challenge");
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();
    println("Let's test your understanding!");
    println();

    println("Question: What is the file extension for compiled SolvraScript modules?");
    println("  a) .svs");
    println("  b) .svc");
    println("  c) .bin");
    println();

    let answer = inp("Your answer (a/b/c): ");
    println();

    if answer == "b" || answer == "B" {
        println("âœ“ Correct! .svc files are compiled bytecode modules.");
        println("  .svs = SolvraScript source code");
        println("  .svc = SolvraCore compiled bytecode");
    } else {
        println("âœ— Not quite. The correct answer is 'b' â€” .svc");
        println("  SolvraScript source files use .svs extension");
        println("  Compiled bytecode modules use .svc extension");
        println("  The 'c' stands for 'compiled'!");
    }
    println();

    let continue5 = inp("Press Enter to see summary...");
    println();

    // Summary
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("ğŸ“‹ Lesson Summary");
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();
    println("Today you learned:");
    println("  âœ“ How to import compiled .svc bytecode modules");
    println("  âœ“ How to execute modules with core_module_execute()");
    println("  âœ“ How to manage module lifecycle with release()");
    println("  âœ“ Why bytecode modules enable efficient execution");
    println();
    println("Key Takeaway:");
    println("  The module system bridges SolvraScript orchestration with");
    println("  compiled SolvraCore artifacts. This hybrid approach combines");
    println("  scripting flexibility with compiled performance!");
    println();

    // Next Steps
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("What would you like to do?");
    println("  [1] View lesson again");
    println("  [2] Continue to next lesson");
    println("  [3] Exit");
    println();

    let choice = inp("Your choice (1/2/3): ");
    println();

    if choice == "1" {
        println("ğŸ“– Restarting lesson...");
        println();
        run_tutorial();
    } else if choice == "2" {
        println("ğŸ“ Great! Continue to memory_basics.svs:");
        println("   ./scripts/learn.sh");
    } else {
        println("ğŸ‘‹ Thanks for learning with us! See you next time.");
    }
    println();
}

fn main() {
    run_tutorial();
}

//--------------------------------------------------
// End comments: Shows how to load, execute, and release compiled bytecode modules
// @ZNOTE: Module system bridges SolvraScript orchestration with compiled SolvraCore artifacts
//--------------------------------------------------

//==================================================
// End of file
//==================================================
