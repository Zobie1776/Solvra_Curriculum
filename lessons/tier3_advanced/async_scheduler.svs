//==================================================
// File: async_scheduler.svs
//==================================================
// Author: ZobieLabs
// License: Duality Public License (DPL v1.0)
// Goal: Coordinate multiple async tasks and surface progress events
// Objective: Demonstrate advanced async patterns with event-driven coordination
//==================================================

//==================================================
// Section 1.0 - Lesson Objective
//==================================================

// Interactive guided tutorial: Master advanced async coordination
// Run with: ./scripts/build.sh lessons/tier3_advanced/async_scheduler.svs

//==================================================
// Section 2.0 - Tutorial Execution
//==================================================

import <string> as strings;

fn log_event(message) {
    println("[event] ", message);
}

async fn schedule_job(name, delay_ms) {
    log_event(strings.concat(name, " -> queued"));
    sleep(delay_ms);
    log_event(strings.concat(name, " -> completed"));
    trigger_event("job_complete", name);
    return strings.concat(name, "-done");
}

fn handle_job_event(payload) {
    println("Observer noted completion: ", payload);
}

fn run_tutorial() {
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘  Tier 3: Advanced Async Scheduler                         â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();

    println("ğŸ“š What you'll learn:");
    println("  â€¢ How to coordinate multiple async tasks");
    println("  â€¢ How to use event-driven programming with SolvraCore");
    println("  â€¢ How to implement observers for async completion");
    println("  â€¢ Advanced patterns for reactive systems");
    println();

    println("Let's begin!");
    println();

    // Concept 1: Event-Driven Architecture
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 1: Event-Driven Architecture");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Event-driven systems react to events rather than polling:");
    println("  â€¢ trigger_event(name, payload) - Emit an event");
    println("  â€¢ on_event(name, handler) - Subscribe to events");
    println();
    println("Benefits:");
    println("  â€¢ Decoupled components (loose coupling)");
    println("  â€¢ Reactive behavior (respond to changes)");
    println("  â€¢ Scalable coordination (many listeners)");
    println();
    println("Perfect for AI micro-agents and async workflows!");
    println();

    let continue1 = inp("Press Enter to continue...");
    println();

    // Concept 2: Event Subscription
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 2: Subscribing to Events");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Register event handlers before spawning tasks:");
    println("  on_event(\"job_complete\", handle_job_event);");
    println();
    println("This lesson will track async job completions!");
    println();

    on_event("job_complete", handle_job_event);
    println("Event handler registered for 'job_complete'");
    println();

    let continue2 = inp("Press Enter to continue...");
    println();

    // Concept 3: Running Coordinated Tasks
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 3: Coordinating Async Tasks");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Spawning multiple tasks with different delays:");
    println("  alpha: 150ms");
    println("  beta:  200ms");
    println();
    println("Watch for event notifications!");
    println();

    let alpha = async schedule_job("alpha", 150);
    let beta = async schedule_job("beta", 200);

    let mut finished = [];

    let result_alpha = await alpha;
    finished = push(finished, result_alpha);

    let result_beta = await beta;
    finished = push(finished, result_beta);

    println();
    println("All tasks completed!");
    println("Finished jobs: ", len(finished));
    println();

    let continue3 = inp("Press Enter to continue...");
    println();

    // Concept 4: Advanced Patterns
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("ğŸ“– Concept 4: Advanced Async Patterns for SolvraCore");
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println();
    println("Use event-driven async for:");
    println("  â€¢ Multi-agent coordination (autonomous agents)");
    println("  â€¢ Sensor data pipelines (IoT devices)");
    println("  â€¢ Service orchestration (microservices)");
    println("  â€¢ Real-time monitoring (dashboards)");
    println();
    println("SolvraCore's event system enables reactive programming");
    println("patterns essential for modern distributed systems!");
    println();

    // Quick self-check
    if len(finished) == 2 {
        println("[Self Check] Scheduler drained all tasks successfully!");
    } else {
        println("[Self Check] Some tasks are still pending!");
    }
    println();

    let continue4 = inp("Press Enter to continue...");
    println();

    // Try-It-Yourself Section
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("âœï¸  Try-It-Yourself Challenge");
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();

    println("Question: What does trigger_event() do?");
    println("  a) Starts a new async task");
    println("  b) Emits an event to registered handlers");
    println("  c) Cancels a running task");
    println();

    let answer = inp("Your answer (a/b/c): ");
    println();

    if answer == "b" || answer == "B" {
        println("âœ“ Correct! trigger_event() emits events to handlers.");
        println("  Handlers are registered with on_event().");
    } else {
        println("âœ— Not quite. The correct answer is 'b'.");
        println("  trigger_event() broadcasts an event to all");
        println("  registered listeners, enabling reactive behavior!");
    }
    println();

    let continue5 = inp("Press Enter to see summary...");
    println();

    // Summary
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("ğŸ“‹ Lesson Summary");
    println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println();
    println("Today you learned:");
    println("  âœ“ Event-driven architecture with trigger/on_event");
    println("  âœ“ Coordinating multiple async tasks");
    println("  âœ“ Implementing observers for completions");
    println("  âœ“ Advanced patterns for reactive systems");
    println();
    println("Key Takeaway:");
    println("  SolvraCore's event system enables reactive programming");
    println("  essential for AI agents, IoT, and distributed systems!");
    println();

    // Next Steps
    println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("What would you like to do?");
    println("  [1] View lesson again");
    println("  [2] Continue to next lesson");
    println("  [3] Exit");
    println();

    let choice = inp("Your choice (1/2/3): ");
    println();

    if choice == "1" {
        println("ğŸ“– Restarting lesson...");
        println();
        run_tutorial();
    } else if choice == "2" {
        println("ğŸ“ Continue to the next Tier 3 lesson!");
    } else {
        println("ğŸ‘‹ Thanks for learning!");
    }
    println();
}

fn main() {
    run_tutorial();
}

//--------------------------------------------------
// @ZNOTE: SolvraCore event system enables reactive programming patterns
//--------------------------------------------------

//==================================================
// End of file
//==================================================
