//==================================================
// File: async_scheduler.svs
//==================================================
// Author: ZobieLabs
// License: Duality Public License (DPL v1.0)
// Goal: Coordinate multiple async tasks and surface progress events
// Objective: Demonstrate advanced async patterns with event-driven coordination
//==================================================

//==================================================
// Section 1.0 - Lesson Objective
//==================================================

// Coordinate multiple async tasks and surface progress events.
// Run with: ./scripts/build.sh lessons/tier3_advanced/async_scheduler.svs
// Try-It: add a third task or adjust the timeout value.

//==================================================
// Section 2.0 - Example Execution
//==================================================

import <string> as strings;

fn log_event(message) {
    println("[event] ", message);
}

async fn schedule_job(name, delay_ms) {
    log_event(strings.concat(name, " -> queued"));
    sleep(delay_ms);
    log_event(strings.concat(name, " -> completed"));
    trigger_event("job_complete", name);
    return strings.concat(name, "-done");
}

fn handle_job_event(payload) {
    println("Observer noted completion -> ", payload);
}

fn run_demo() {
    println("=== Unified async runner ===");

    // Try-It: Configure task delays interactively
    let delay_alpha_input = inp("Enter delay for alpha task in ms (or press Enter for 150): ");
    let delay_beta_input = inp("Enter delay for beta task in ms (or press Enter for 200): ");
    let spawn_gamma = inp("Spawn a third task 'gamma'? (y/n, or press Enter for no): ");

    let delay_alpha = 150;
    let delay_beta = 200;

    if len(delay_alpha_input) > 0 {
        delay_alpha = parse_int(delay_alpha_input);
        if delay_alpha < 0 {
            delay_alpha = 150;
        }
    }

    if len(delay_beta_input) > 0 {
        delay_beta = parse_int(delay_beta_input);
        if delay_beta < 0 {
            delay_beta = 200;
        }
    }

    on_event("job_complete", handle_job_event);

    let alpha = async schedule_job("alpha", delay_alpha);
    let beta = async schedule_job("beta", delay_beta);

    let mut finished = [];

    let result_alpha = await alpha;
    finished = push(finished, result_alpha);

    let result_beta = await beta;
    finished = push(finished, result_beta);

    if spawn_gamma == "y" || spawn_gamma == "Y" {
        let gamma = async schedule_job("gamma", 100);
        let result_gamma = await gamma;
        finished = push(finished, result_gamma);
    }

    println("Finished jobs -> ", len(finished));

    let expected_count = 2;
    if spawn_gamma == "y" || spawn_gamma == "Y" {
        expected_count = 3;
    }

    if len(finished) == expected_count {
        println("[Self Check] Scheduler drained all tasks.");
    } else {
        println("[Self Check] Scheduler still has pending tasks.");
    }

    println("Try-It Yourself: register a second event handler that counts completions.");
}

fn main() {
    run_demo();
}

//--------------------------------------------------
// End comments: Advanced async coordination with event-driven task tracking
// @ZNOTE: SolvraCore event system enables reactive programming patterns
//--------------------------------------------------

//==================================================
// End of file
//==================================================
